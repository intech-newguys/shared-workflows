name: Frontend SSR Build & Push (Multi-Partner)

on:
  workflow_call:
    inputs:
      repository-name:
        description: Base ECR repository name
        type: string
        required: true
      partners:
        description: 'JSON array of partner domains, e.g. ["betonly.com","semabet.ug"]'
        type: string
        required: true
      dockerfile:
        description: Path to Dockerfile
        type: string
        required: false
        default: './Dockerfile'
      build-context:
        description: Docker build context
        type: string
        required: false
        default: '.'
      cloudflare-purge:
        description: Enable Cloudflare cache purge (skipped for prod)
        type: boolean
        required: false
        default: true
    secrets:
      AWS_ROLE_ARN:
        required: true
      SLACK_TOKEN:
        required: true
      CLOUDFLARE_TOKEN:
        required: false
      JIRA_WEBHOOKS_JSON:
        required: false
      DEPLOY_TOKEN:
        description: GitHub token with write access to k8s-newguys-services
        required: false

env:
  AWS_REGION: eu-west-2
  ECR_REGISTRY: 500500308151.dkr.ecr.eu-west-2.amazonaws.com

jobs:
  build:
    runs-on: arc-runner-set
    permissions:
      id-token: write
      contents: read
    env:
      HAS_DEPLOY_TOKEN: ${{ secrets.DEPLOY_TOKEN != '' }}
      HAS_JIRA_WEBHOOKS: ${{ secrets.JIRA_WEBHOOKS_JSON != '' }}
      HAS_CLOUDFLARE_TOKEN: ${{ secrets.CLOUDFLARE_TOKEN != '' }}
    steps:
      - name: Detect environment from branch
        id: env
        run: |
          BRANCH="${GITHUB_REF_NAME}"
          case "$BRANCH" in
            dev|qa|stage|prod) ENV="$BRANCH" ;;
            sandbox) ENV="stage" ;;
            *) echo "Branch $BRANCH not configured for deployment"; exit 0 ;;
          esac
          echo "env=$ENV" >> "$GITHUB_OUTPUT"
          echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 5

      - name: Slack — build started
        uses: intech-newguys/shared-workflows/actions/slack-notify@main
        continue-on-error: true
        with:
          status: started
          slack-token: ${{ secrets.SLACK_TOKEN }}
          channel: front-deployments-${{ steps.env.outputs.branch }}
          repo-name: ${{ github.event.repository.name }}
          branch: ${{ steps.env.outputs.branch }}
          commit-author: ${{ github.actor }}

      - name: Install AWS CLI
        run: |
          if ! command -v aws &>/dev/null; then
            curl -fsSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o /tmp/awscliv2.zip
            unzip -q /tmp/awscliv2.zip -d /tmp
            /tmp/aws/install --install-dir "$HOME/.local/aws-cli" --bin-dir "$HOME/.local/bin"
            echo "$HOME/.local/bin" >> "$GITHUB_PATH"
            rm -rf /tmp/awscliv2.zip /tmp/aws
          fi
          ${HOME}/.local/bin/aws --version || aws --version

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Ensure ECR repos and lifecycle policies
        run: |
          PARTNERS='${{ inputs.partners }}'
          for DOMAIN in $(echo "$PARTNERS" | jq -r '.[]'); do
            SLUG=$(echo "$DOMAIN" | sed 's/\.com$//' | sed 's/\./-/g')
            REPO_NAME="${{ inputs.repository-name }}-${SLUG}"

            if ! aws ecr describe-repositories --repository-names "$REPO_NAME" 2>/dev/null; then
              echo "Creating ECR repo: $REPO_NAME"
              aws ecr create-repository --repository-name "$REPO_NAME" \
                --image-scanning-configuration scanOnPush=false \
                --encryption-configuration encryptionType=AES256
            fi

            if ! aws ecr get-lifecycle-policy --repository-name "$REPO_NAME" 2>/dev/null; then
              echo "Applying lifecycle policy to: $REPO_NAME"
              aws ecr put-lifecycle-policy --repository-name "$REPO_NAME" --lifecycle-policy-text '{
                "rules": [
                  {
                    "rulePriority": 1,
                    "description": "Expire untagged images after 1 day",
                    "selection": {
                      "tagStatus": "untagged",
                      "countType": "sinceImagePushed",
                      "countUnit": "days",
                      "countNumber": 1
                    },
                    "action": { "type": "expire" }
                  },
                  {
                    "rulePriority": 2,
                    "description": "Keep last 10 images per env",
                    "selection": {
                      "tagStatus": "tagged",
                      "tagPatternList": ["dev-*", "qa-*", "stage-*", "prod-*"],
                      "countType": "imageCountMoreThan",
                      "countNumber": 10
                    },
                    "action": { "type": "expire" }
                  }
                ]
              }'
            fi

            echo "ECR repo ready: $REPO_NAME"
          done

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image (all partner tags)
        run: |
          BRANCH="${{ steps.env.outputs.branch }}"
          BUILD_NUM="${{ github.run_number }}"
          PARTNERS='${{ inputs.partners }}'
          BASE_REPO="${{ inputs.repository-name }}"

          # Build tag arguments for all partners
          TAG_ARGS=""
          FIRST_SLUG=""
          for DOMAIN in $(echo "$PARTNERS" | jq -r '.[]'); do
            SLUG=$(echo "$DOMAIN" | sed 's/\.com$//' | sed 's/\./-/g')
            REPO="${{ env.ECR_REGISTRY }}/${BASE_REPO}-${SLUG}"
            TAG_ARGS="$TAG_ARGS -t ${REPO}:${BRANCH}-${BUILD_NUM} -t ${REPO}:${BRANCH}-latest"
            if [ -z "$FIRST_SLUG" ]; then
              FIRST_SLUG="$SLUG"
            fi
          done

          # Use first partner repo for cache
          CACHE_REPO="${{ env.ECR_REGISTRY }}/${BASE_REPO}-${FIRST_SLUG}"

          docker buildx build \
            --push \
            --file ${{ inputs.dockerfile }} \
            --cache-from=type=registry,ref=${CACHE_REPO}:cache \
            --cache-to=type=registry,ref=${CACHE_REPO}:cache,mode=max,image-manifest=true \
            --provenance=false \
            $TAG_ARGS \
            ${{ inputs.build-context }}

      - name: Update image tag in k8s-newguys-services
        if: env.HAS_DEPLOY_TOKEN == 'true'
        env:
          DEPLOY_TOKEN: ${{ secrets.DEPLOY_TOKEN }}
        run: |
          BRANCH="${{ steps.env.outputs.branch }}"
          SERVICE="${{ inputs.repository-name }}"
          IMAGE_TAG="${BRANCH}-${{ github.run_number }}"
          REPO="intech-newguys/k8s-newguys-services"

          git clone --depth 1 "https://x-access-token:${DEPLOY_TOKEN}@github.com/${REPO}.git" _k8s-services
          cd _k8s-services

          VALUES_FILE="${BRANCH}/${SERVICE}/values.yaml"
          if [ ! -f "$VALUES_FILE" ]; then
            echo "No values file at ${VALUES_FILE}, skipping deploy"
            cd .. && rm -rf _k8s-services
            exit 0
          fi

          sed -i "s|^\(\s*tag:\).*|\1 ${IMAGE_TAG}|" "$VALUES_FILE"
          rm -f "${BRANCH}/.argocd-source-${SERVICE}.yaml"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git diff --cached --quiet && echo "No changes to commit" && exit 0
          git commit -m "deploy: ${SERVICE} ${IMAGE_TAG}"
          git push

          cd .. && rm -rf _k8s-services

      - name: Purge Cloudflare cache
        if: inputs.cloudflare-purge && steps.env.outputs.branch != 'prod' && env.HAS_CLOUDFLARE_TOKEN == 'true'
        continue-on-error: true
        env:
          CF_TOKEN: ${{ secrets.CLOUDFLARE_TOKEN }}
        run: |
          BRANCH="${{ steps.env.outputs.branch }}"
          PARTNERS='${{ inputs.partners }}'

          for DOMAIN in $(echo "$PARTNERS" | jq -r '.[]'); do
            BASE_DOMAIN=$(echo "$DOMAIN" | awk -F. '{print $(NF-1)"."$NF}')
            ZONE_ID=$(curl -s -H "Authorization: Bearer ${CF_TOKEN}" \
              "https://api.cloudflare.com/client/v4/zones?name=${BASE_DOMAIN}" \
              | jq -r '.result[0].id // empty')

            if [ -z "$ZONE_ID" ]; then
              echo "Zone not found for $BASE_DOMAIN"
              continue
            fi

            HOSTNAME="${BRANCH}.${DOMAIN}"
            echo "Purging Cloudflare cache for ${HOSTNAME} (zone: ${ZONE_ID})"
            curl -s -X POST "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/purge_cache" \
              -H "Authorization: Bearer ${CF_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "{\"hosts\": [\"${HOSTNAME}\"]}"
          done

      - name: Update Jira tickets
        if: env.HAS_JIRA_WEBHOOKS == 'true'
        uses: intech-newguys/shared-workflows/actions/jira-update@main
        continue-on-error: true
        with:
          branch: ${{ steps.env.outputs.branch }}
          jira-webhooks-json: ${{ secrets.JIRA_WEBHOOKS_JSON }}

      - name: Slack — build result
        if: always()
        uses: intech-newguys/shared-workflows/actions/slack-notify@main
        continue-on-error: true
        with:
          status: ${{ job.status }}
          slack-token: ${{ secrets.SLACK_TOKEN }}
          channel: front-deployments-${{ steps.env.outputs.branch }}
          repo-name: ${{ github.event.repository.name }}
          branch: ${{ steps.env.outputs.branch }}
          commit-author: ${{ github.actor }}
